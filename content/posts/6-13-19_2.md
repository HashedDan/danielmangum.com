+++ 
draft = true
date = 2019-06-13T09:31:39-05:00
title = "HashiCode Ep. 1: Terraform Remote Backend Locking"
slug = "tf-remote-backend-locking" 
tags = []
categories = []
+++

*This is the first installment of HashiCode, a blog post series where I go through the source code of HashiCorp tools to learn more about what happens behind the scenes when you interact with tools as a user.*

One of the issues that teams using Terraform to provision infrastructure run into quickly is managing who is changing what and at what time are they doing it. Terraform introduces the concept of remote state, which allows users to interact with the same existing infrastructure resources. While this is powerful, it also provides more opportunities for issues. One of the most common solutions is **locking**.

If you have ever interacted with a database, you may be familiar with the concept of locking. It solves the problem of data races when two different sessions are attempting to modify the same value at the same time. A common example is banking: imagine you have $100 in your bank account. If you deposited $20 and another user on your bank account deposited $50 at the same time, there is potential that one transaction overwrites the other. In short, if the second transaction begins before the first transaction ends, your bank balance will only be $150 instead of $170 when the second transaction ends. This is because when the second transaction started the bank account had $100 in it, and it increased that value by $50 and committed it.

Locking solves this by *locking* writes to the database when a transaction starts. So going back to the bank example, when the first transaction begins it would take out a lock on the account, and when the second transaction wanted to begin, it would be told to wait until the first finished. The first would finish, bringing the balance to $120, then release the lock. The second would then take out a lock, and since the first transaction has completed and been committed, would then increase the balance to $150, before releasing the lock. This is a simple example, and there are multiple locking strategies that can be implemented to address certain types of collisions, but I will leave you to research more about that on your own. One of my favorite summaries is [here](http://www.agiledata.org/essays/concurrencyControl.html), and if you are interested in how locking is actually implemented in common database management systems take a look [here](https://www.geeksforgeeks.org/implementation-of-locking-in-dbms/).

You may have already begun to see how this could come up in modifying remote state, and how a `.tfstate` file is much like a database. Just like collisions may occur when multiple parties are writing to a database, collisions may also occur when modifying infrastructure. For instance, if I want to add a target group to an application load balancer on AWS, and you want to delete that load balancer at the same time, what happens? As previously mentioned, if we are sharing state remotely, we are modifying the same source of truth.

S3 is a common place to store shared state files for Terraform.

## The S3 Remote State Backend

`terraform/backend/remote-state/s3`

## What happens when we run a plan?