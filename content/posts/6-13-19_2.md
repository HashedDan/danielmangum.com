+++ 
draft = true
date = 2019-06-13T09:31:39-05:00
title = "HashiCode Ep. 1: Terraform Remote Backend Locking"
slug = "tf-remote-backend-locking" 
tags = []
categories = []
+++

*This is the first installment of HashiCode, a blog post series where I go through the source code of HashiCorp tools to learn more about what happens behind the scenes when you interact with tools as a user.*

*Disclaimer: this episode is referencing code from the Terraform codebase as of commit [43a7548](https://github.com/hashicorp/terraform/tree/43a754829ae7afcb26bccd275fb3ae9d3e0cda88). Becuase Terraform is a constanly evolving open source tool, the code is subject to change. However, the ideas expressed will largely remain the same.*

One of the issues that teams using Terraform to provision infrastructure run into quickly is managing who is changing what and at what time are they doing it. Terraform introduces the concept of [remote state](https://www.terraform.io/docs/state/remote.html), which allows users to interact with the same existing infrastructure resources. While this is powerful, it also provides more opportunities for issues. One of the most common solutions is **locking**.

If you have ever interacted with a database, you may be familiar with the concept of locking. It solves the problem of data races when two different sessions are attempting to modify the same value at the same time. A common example is banking: imagine you have $100 in your bank account. If you deposited $20 and another user on your bank account deposited $50 at the same time, there is potential that one transaction overwrites the other. In short, if the second transaction begins before the first transaction ends, your bank balance will only be $150 instead of $170 when the second transaction ends. This is because when the second transaction started the bank account had $100 in it, and it increased that value by $50 and committed it.

Locking solves this by *locking* writes to the database when a transaction starts. So going back to the bank example, when the first transaction begins it would take out a lock on the account, and when the second transaction wanted to begin, it would be told to wait until the first finished. The first would finish, bringing the balance to $120, then release the lock. The second would then take out a lock, and since the first transaction has completed and been committed, would then increase the balance to $150, before releasing the lock. This is a simple example, and there are multiple locking strategies that can be implemented to address certain types of collisions, but I will leave you to research more about that on your own. One of my favorite summaries is [here](http://www.agiledata.org/essays/concurrencyControl.html), and if you are interested in how locking is actually implemented in common database management systems take a look [here](https://www.geeksforgeeks.org/implementation-of-locking-in-dbms/).

You may have already begun to see how this could come up in modifying remote state, and how a `.tfstate` file is much like a database. Just like collisions may occur when multiple parties are writing to a database, collisions may also occur when modifying infrastructure. For instance, if I want to add a target group to an application load balancer on AWS, and you want to delete that load balancer at the same time, what happens? Similarly, if I want to reference outputs from the state of another Terraform configuration, what happens if the state of that configuration is being changed while I try to read it? As previously mentioned, if we are sharing state remotely, we are interacting with the same source of truth.

[S3](https://aws.amazon.com/s3/) is a common place to store shared state files for Terraform. Terraform allows for the use of multiple types of backends, and S3 has been one of the most popular since it was implemented as a remote state wrapper by Gruntwork's [Terragrunt](https://github.com/gruntwork-io/terragrunt) prior to officially being fully implemented within Terraform itself. It works with [DynamoDB](https://aws.amazon.com/dynamodb/) to allow for full backend functionality, which includes storage, versioning, encryption, and locking. As we look through the actual Terraform [source code](https://github.com/hashicorp/terraform) to see how S3 is implemented as a backend, we can gain a greater understanding for what happens when we use it and how we can leverage it within an organization.

## A Background on Backends

If you have ever used Terraform you are probably familair with the concept of `.tfstate` files. Whether you know exactly how they are constructed, or you just know that they are a remnant of running most Terraform operations, they are handling a big part of the functionality of Terraform. They keep track of what has already been provisioned, which allows Terraform to know what exists, how it can be updated / deleted, and how new resources can interact with existing. If you were to delete a `.tfstate` file, then run `tf apply`, Terraform would recreate all the resources defined in your configuration, and you be no longer able to manage the existing resources that you previously deployed.

Backends come in two flavors in Terraform: *standard* and *enhanced*. The difference between the two is pretty straightforward. Most backends are standard, which means they basically just manage state. Enhanced backends do this as well, but also can execute remote operations so that you can initiate Terraform commands from your local machine, but then go about your day as the provisioning process is offloaded to an enhanced backend. You can read more about the difference between types of backends [here](https://www.terraform.io/docs/backends/types/index.html), but it is useful to think about backends by talking about the one that you are probably already familiar with: **local**.

Local itself is an enhanced backend because it both handles state and can execute operations. Backends are basically just engines, giving Terraform the compute and storage resources (and some light logic to interact with them) that it needs to work. Because we are primarily interested in the topic of remote state locking, we will focus in only on the the subset of functionality that is encompassed by a standard backend. So how does the local backend handle state? Well we already alluded to it earlier. It uses your local file system and creates `.tfstate` files. But it actually doesn't have to! While there are two types of backends, we actually *always are using an enhanced backend*. This is because to ever interact with a standard backend we must go through an enhanced one (namely `local`, more on this later).

> The local backend, which is of type *backend.Enhanced* is actually used to execute all of the backends of type *backend.Backend*.

To truly understand this, we must look into the source code. HashiCorp tools are mostly written in Go ([Vagrant](https://github.com/hashicorp/vagrant), the oldest tool, is written in Ruby). A common design pattern in Go, and most programming languages for that matter, is to define an interface which describes the functionality of a broad type, and then have multiple implementations that adhere to the specifications. HashiCorp utilizes this pattern quite heavily, and it allows for the tools to be built using a "plugin" architecture, which has been a significant factor in their rapid adoption and growth (we will certainly be diving deeper into this plugin architecture in later episodes of HashiCode). Importantly, both the "internal" (or built-in) and extendable parts of Terraform are constructed in this manner, and backends, which would be considered internal in this case are no exception.

The general `Backend` interface is defined in [`terraform/backend/backend.go`](https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/backend.go). Here is a snippet of it in which I have removed code comments for brevity:

```
// Backend is the minimal interface that must be implemented to enable Terraform.
type Backend interface {
	ConfigSchema() *configschema.Block
	PrepareConfig(cty.Value) (cty.Value, tfdiags.Diagnostics)
	Configure(cty.Value) tfdiags.Diagnostics
	StateMgr(workspace string) (statemgr.Full, error)
	DeleteWorkspace(name string) error
	Workspaces() ([]string, error)
}
```

As the comment on the exported `Backend` interface suggests, this is the "minimal interface that must be implemented". If we go back and think about our two types of backends (standard and enhanced) and remember that the functionality of an enhanced backend is a *superset* of that of the standard backend, then we can reach the conclusion that a standard backend must implement these six methods, while an enhanced backend must implement these six plus some more. And the code reflects this! If we look just below the `Backend` interface, we see the `Enhanced` interface (comments preserved this time):

```
// Enhanced implements additional behavior on top of a normal backend.
//
// Enhanced backends allow customizing the behavior of Terraform operations.
// This allows Terraform to potentially run operations remotely, load
// configurations from external sources, etc.
type Enhanced interface {
	Backend

	// Operation performs a Terraform operation such as refresh, plan, apply.
	// It is up to the implementation to determine what "performing" means.
	// This DOES NOT BLOCK. The context returned as part of RunningOperation
	// should be used to block for completion.
	// If the state used in the operation can be locked, it is the
	// responsibility of the Backend to lock the state for the duration of the
	// running operation.
	Operation(context.Context, *Operation) (*RunningOperation, error)
}
```

Here we see another powerful property of Go, the ability for one interface to *wrap* another. This concept is called *composition*. Most programming languages allow for composition, but users frequently confuse composition with inheritance. Go does not provide classes or inheritance, but instead achieves polymorphism through composition and struct embedding. In this way, eliminates the fundamental problem of a [fragile base class](https://en.wikipedia.org/wiki/Fragile_base_class) in object oriented programming. Composition an interface esstentially is just saying "I will do everything this interface does, plus some more". So here, `Enhanced` is saying that it will do everything that `Backend` does, but also implement the ability to execute `Operation()`. This is exactly what we stated earlier about standard and enhanced backends: enhanced backends can do everything standard ones do, but can also execute *remote operations*. Do not take the clarity of this code for granted. You will see many code bases that are not near as readable / understandable as this, which is both a nod to the Go language and also to Mitchell Hashimoto, one of the founders of HashiCorp and the writer of this very block of code (You can actually check out the commit message where this was added [`here`](https://github.com/hashicorp/terraform/commit/8a070ddef0659652636fcf570988c33eee19ec6b). The fact that it has not been touched for two years is a pretty solid indication of the effectiveness of the initial implementation).

So back to our original question: why do we have to go through an enhanced backend to interact with a standard one? Well if we consider that Terraform must always be able to execute operations and must always be able to handle state, and we also acknowledge that both of these things are always handled by a backend, then we reach the conclusion that we can never only be using a standard backend because we would be unable to execute any operations. If this still feels confusing, let's consider that there are only two types of enhanced backends: `local` and `remote` (i.e. Terraform Enterprise). Remote performs operations (i.e. `Operation()`) and manages state (i.e. `Backend`) in Terraform Enterprise. Local, on the other hand, performs operations locally, but can substitute either local or a remote-state `Backend` to manage state.

This is a good time to look at the structure of the `terraform/backend` directory.

```
backend/
    atlas/          # Legacy backend Atlas support
    init/           # Provides initialization methods for each backend type to Terraform
    local/          # Local backend that implements Enhanced
    remote/         # Remote (TF Enterprise) backend that implements Enhanced
    remote-state/   # Remote state backends that implement Backend
    backend.go      # Backend and Enhanced interfaces
    ...
```

As you can see, the directory structure closely reflects the separation of functionality for each backend. If we look into [`terraform/backend/init/init.go`](https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/init/init.go) we can see how each backend implementation is exposed to Terraform:

```
// Init initializes the backends map with all our hardcoded backends.
func Init(services *disco.Disco) {
	backendsLock.Lock()
	defer backendsLock.Unlock()

	backends = map[string]backend.InitFn{
		// Enhanced backends.
		"local":  func() backend.Backend { return backendLocal.New() },
		"remote": func() backend.Backend { return backendRemote.New(services) },

		// Remote State backends.
		"artifactory": func() backend.Backend { return backendArtifactory.New() },
		"atlas":       func() backend.Backend { return backendAtlas.New() },
		"azurerm":     func() backend.Backend { return backendAzure.New() },
		"consul":      func() backend.Backend { return backendConsul.New() },
		"etcd":        func() backend.Backend { return backendEtcdv2.New() },
		"etcdv3":      func() backend.Backend { return backendEtcdv3.New() },
		"gcs":         func() backend.Backend { return backendGCS.New() },
		"http":        func() backend.Backend { return backendHTTP.New() },
		"inmem":       func() backend.Backend { return backendInmem.New() },
		"manta":       func() backend.Backend { return backendManta.New() },
		"oss":         func() backend.Backend { return backendOSS.New() },
		"pg":          func() backend.Backend { return backendPg.New() },
		"s3":          func() backend.Backend { return backendS3.New() },
		"swift":       func() backend.Backend { return backendSwift.New() },

		// Deprecated backends.
		"azure": func() backend.Backend {
			return deprecateBackend(
				backendAzure.New(),
				`Warning: "azure" name is deprecated, please use "azurerm"`,
			)
		},
	}
}
```

Now let's venture into [`terraform/backend/local/backend.go`](https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/local/backend.go). Luckily for us, the comments are verbose and do a great job of explaining exactly what we are looking at:

```
// Local is an implementation of EnhancedBackend that performs all operations
// locally. This is the "default" backend and implements normal Terraform
// behavior as it is well known.
type Local struct {
	// CLI and Colorize control the CLI output. If CLI is nil then no CLI
	// output will be done. If CLIColor is nil then no coloring will be done.
	CLI      cli.Ui
	CLIColor *colorstring.Colorize

	// ShowDiagnostics prints diagnostic messages to the UI.
	ShowDiagnostics func(vals ...interface{})

	// The State* paths are set from the backend config, and may be left blank
	// to use the defaults. If the actual paths for the local backend state are
	// needed, use the StatePaths method.
	//
	// StatePath is the local path where state is read from.
	//
	// StateOutPath is the local path where the state will be written.
	// If this is empty, it will default to StatePath.
	//
	// StateBackupPath is the local path where a backup file will be written.
	// Set this to "-" to disable state backup.
	//
	// StateWorkspaceDir is the path to the folder containing data for
	// non-default workspaces. This defaults to DefaultWorkspaceDir if not set.
	StatePath         string
	StateOutPath      string
	StateBackupPath   string
	StateWorkspaceDir string

	// The OverrideState* paths are set based on per-operation CLI arguments
	// and will override what'd be built from the State* fields if non-empty.
	// While the interpretation of the State* fields depends on the active
	// workspace, the OverrideState* fields are always used literally.
	OverrideStatePath       string
	OverrideStateOutPath    string
	OverrideStateBackupPath string

	// We only want to create a single instance of a local state, so store them
	// here as they're loaded.
	states map[string]statemgr.Full

	// Terraform context. Many of these will be overridden or merged by
	// Operation. See Operation for more details.
	ContextOpts *terraform.ContextOpts

	// OpInput will ask for necessary input prior to performing any operations.
	//
	// OpValidation will perform validation prior to running an operation. The
	// variable naming doesn't match the style of others since we have a func
	// Validate.
	OpInput      bool
	OpValidation bool

	// Backend, if non-nil, will use this backend for non-enhanced behavior.
	// This allows local behavior with remote state storage. It is a way to
	// "upgrade" a non-enhanced backend to an enhanced backend with typical
	// behavior.
	//
	// If this is nil, local performs normal state loading and storage.
	Backend backend.Backend

	// RunningInAutomation indicates that commands are being run by an
	// automated system rather than directly at a command prompt.
	//
	// This is a hint not to produce messages that expect that a user can
	// run a follow-up command, perhaps because Terraform is running in
	// some sort of workflow automation tool that abstracts away the
	// exact commands that are being run.
	RunningInAutomation bool

	// opLock locks operations
	opLock sync.Mutex
}

var _ backend.Backend = (*Local)(nil)

// New returns a new initialized local backend.
func New() *Local {
	return NewWithBackend(nil)
}

// NewWithBackend returns a new local backend initialized with a
// dedicated backend for non-enhanced behavior.
func NewWithBackend(backend backend.Backend) *Local {
	return &Local{
		Backend: backend,
	}
}
```

The first thing you may notice is the `Local` struct, which has comments that conveniently tell us that it implements EnhancedBackend (i.e. `backend.Enhanced`). As we have said many times, an enhanced backend (`backend.Enhanced`) must implement everything that a standard (`backend.Backend`) does, plus be able to perform operations. If you look farther down in this file, you will see the following methods implemented:

```
func (b *Local) ConfigSchema() *configschema.Block
func (b *Local) PrepareConfig(obj cty.Value) (cty.Value, tfdiags.Diagnostics)
func (b *Local) Configure(obj cty.Value) tfdiags.Diagnostics
func (b *Local) Workspaces() ([]string, error)
func (b *Local) DeleteWorkspace(name string) error
func (b *Local) StateMgr(name string) (statemgr.Full, error)
```

We recognize these as implementations of the six required methods found in `backend.Backend`. So we can think of these as the standard backend methods that are used to handle state. You can also see in the `Local` struct that there is a field Backend of type `backend.Backend`. This reminds us a lot of how the `backend.Enhanced` interface (which `Local` is implementing here) wrapped `backend.Backend`! However, I said earlier that `local` may manage state itself, or substitute in one of the `remote-state` backends to do so. How does that work? Well let's look back up to `New()` and `NewWithBackend()` just after the `Local` struct. If you look closely, you can see that `New()` simply calls `NewWithBackend(nil)` which sets the `Backend` field of `Local` to `nil`. Then, if we look at each of the six methods defined to implement `backend.Backend`, we notice that they all start with the following code block:

```
    if b.Backend != nil {
		return b.Backend.ConfigSchema() # This is the example from ConigSchema()
	}
```

This basically says if we have substituted in another `backend.Backend` (i.e. `b.Backend != nil`) then turn over the implementation of this method to that backend. Otherwise, the method as defined in `Local` will execute. This is the behavior that you may be familiar with. If you look through these methods and their child methods, you will notice the functionality defined to write local `.tfstate` files and manage all state in your filesystem. However, the `Operation()` method, which is also defined farther down in this file, does not contain the same code block to check which backend is configured. This is because `Operation()` is part of `backend.Enhanced`, so the given `backend.Backend` is standard so is not able to execute operations.

> In short, `Local` must manage operations, but may or may not manage state.

## The S3 Remote State Backend

So let's take a look at one of the `backend.Backend` implementations that `Local` might push off handling state to. These are kept in [`terraform/backend/remote-state](https://github.com/hashicorp/terraform/tree/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/remote-state). Upon navigating to the directory you will see a multitude of implementations ranging from Consul to Etcd. 

## What happens when we run a plan?